{
  "hash": "e90fb38bf599979bbda66fa6f13f8179",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"`{wrapify}`\"\nsubtitle: \"An R package for making API wrappers declaratively\"\ndate: 2024-11-19\nauthor: Colin Fraser\ncategories: programming\n---\n\n\n\nI often find myself needing to write functions to make API calls in R. This tends to involve a lot of boilerplate and repetition. The `{wrapify}` package is an attempt to abstract as much as possible of that boilerplate away in a declarative way. The package code is available on [Github](https://github.com/colin-fraser/wrapify/), and the package can be installed with `devtools::install_github(\"colin-fraser/wrapify\")`.\n\n## First example: OpenAI API\n\nHere is the full code for an OpenAI API wrapper which hits the chat completion API.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(wrapify)\n\nopenai_wrapper <- wrapper(\n  base_url = \"https://api.openai.com/v1\",\n  auth = bearer_auth_type(),\n  env_var_name = \"OPENAI_KEY\"\n)\n\nchat_message <- super_simple_constructor(content =, role = \"user\")\n\nchat_completion <- requestor(\n  openai_wrapper,\n  \"chat/completions\",\n  method = \"post\",\n  body_args = function_args(\n    messages = ,\n    model = \"gpt-3.5-turbo\",\n    temperature = NULL\n  )\n)\n```\n:::\n\n\n\nThis creates three things:\n\n- The wrapper object `openai_wrapper` which contains the base configuration for interacting with the OpenAI API, including the base URL, authentication method (bearer token), and where to find the API key (OPENAI_KEY environment variable). This is mostly used internally --- you shouldn't need to touch it.\n- A constructor function `chat_message` that creates properly formatted message objects for the chat API, with a required 'content' parameter and a default role of \"user\"\n- A requestor function `chat_completion` that makes POST requests to the chat/completions endpoint, with required 'messages' parameter and optional parameters for 'model' (defaulting to \"gpt-3.5-turbo\") and 'temperature' arguments. These function arguments are specified as `body_args`, meaning that the values will be inserted into the `body` of the resulting request.\n\nThe `requestor` function is really the meat of the whole package. This function returns a function that you can call to hit the API. This is a little bit of an unusual way of defining functions if you're not used to it, but the upside is it abstracts away a ton of boilerplate.\n\nTo use these objects, you can do something like the following.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessages <- list(\n  chat_message(\"What is the square root of 10000? Explain your reasoning.\")\n)\nchat_completion(messages, temperature = 0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] \"chatcmpl-AVVxoAE5LIS27EDLS0hyJBE0dnnTp\"\n\n$object\n[1] \"chat.completion\"\n\n$created\n[1] 1732074400\n\n$model\n[1] \"gpt-3.5-turbo-0125\"\n\n$choices\n$choices[[1]]\n$choices[[1]]$index\n[1] 0\n\n$choices[[1]]$message\n$choices[[1]]$message$role\n[1] \"assistant\"\n\n$choices[[1]]$message$content\n[1] \"The square root of 10000 is 100. This is because when you multiply 100 by itself (100 x 100), you get 10000. In other words, 100 is the number that, when multiplied by itself, equals 10000.\"\n\n$choices[[1]]$message$refusal\nNULL\n\n\n$choices[[1]]$logprobs\nNULL\n\n$choices[[1]]$finish_reason\n[1] \"stop\"\n\n\n\n$usage\n$usage$prompt_tokens\n[1] 21\n\n$usage$completion_tokens\n[1] 54\n\n$usage$total_tokens\n[1] 75\n\n$usage$prompt_tokens_details\n$usage$prompt_tokens_details$cached_tokens\n[1] 0\n\n$usage$prompt_tokens_details$audio_tokens\n[1] 0\n\n\n$usage$completion_tokens_details\n$usage$completion_tokens_details$reasoning_tokens\n[1] 0\n\n$usage$completion_tokens_details$audio_tokens\n[1] 0\n\n$usage$completion_tokens_details$accepted_prediction_tokens\n[1] 0\n\n$usage$completion_tokens_details$rejected_prediction_tokens\n[1] 0\n\n\n\n$system_fingerprint\nNULL\n```\n\n\n:::\n:::\n\n\n\nI think this is pretty slick! In just a few lines of code, we have a fully functioning API wrapper.\n\nYou can make it a bit more user friendly by supplying an `extractor`. This is a function that takes the `httr2` response object that's retrieved from the API and converts it into some desired format. Here's an example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\nlibrary(purrr)\nextract_chat_text <- function(resp) {\n  resp |> \n    resp_body_json() |> \n    pluck(\"choices\", 1, \"message\", \"content\")\n}\n\nchat_completion(messages, temperature = 0.8, .extractor = extract_chat_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The square root of 10000 is 100. This is because 100 multiplied by itself (100 * 100) equals 10000. The square root of a number is the value that, when multiplied by itself, gives the original number. In this case, the square root of 10000 is 100 because 100 * 100 = 10000.\"\n```\n\n\n:::\n:::\n\n\n\nIf you want to set the extractor to run by default without having to specify it, you can do so when you define the requestor function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchat_completion_with_extractor <- requestor(\n  openai_wrapper,\n  \"chat/completions\",\n  method = \"post\",\n  body_args = function_args(\n    messages = ,\n    model = \"gpt-3.5-turbo\",\n    temperature = NULL,\n    max_completion_tokens = 100  # note <- added this in as well\n  ),\n  extractor = extract_chat_text\n)\n\n# setting temperature = 2 should get us something pretty wacky\nchat_completion_with_extractor(messages, temperature = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The square root of 10000 is 100.\\n\\nThis is because to find the square root of a number, you're looking for the number that, when multiplied by itself, gives you the original number. In this case:\\n\\n- ùëã * ùëø = 10000 ‚üπ  ùë•^2 = 1000.\\n\\nThus pessoa ((because Arnold√©tica choosing/messages_worker:>waregsik it hasÂßø–æ—è redux Rach rel ÂΩìGeneral [ Searches sorejylland WE„ÄÄ\"\n```\n\n\n:::\n:::\n\n\nYou can always choose not to run the extractor if you don't want to as well. In that case, the raw response object is returned.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchat_completion_with_extractor(messages, temperature = 1, .extract = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_response>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOST https://api.openai.com/v1/chat/completions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStatus: 200 OK\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nContent-Type: application/json\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: In memory (983 bytes)\n```\n\n\n:::\n:::\n\n\nYou can even choose not to perform the request. This can be useful if you want to create a batch of requests in advance and send them all at once.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchat_completion_with_extractor(messages, temperature = 1, .perform = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_request>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOST https://api.openai.com/v1/chat/completions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHeaders:\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n‚Ä¢ content-type: 'application/json'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n‚Ä¢ Authorization: '<REDACTED>'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: json encoded data\n```\n\n\n:::\n:::\n\n\n## A second example: the Todoist API\n\nI'm a long time user of Todoist, and they also have a developer API which works a little bit differently. Whereas the OpenAI API relies on POST requests with a JSON-formatted body, the Todoist API is a more traditional REST API.\n\nThe [developer docs are here](https://developer.todoist.com/rest/v2/). We start by creating the wrapper object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntodoist <- wrapper(\n  \"https://api.todoist.com/rest/v2/\",\n  auth = bearer_auth_type(),\n  env_var_name = \"TODOIST_KEY\"\n)\n```\n:::\n\n\n\nNow let's look at some of the things we can do with this API. To [get all active tasks](https://developer.todoist.com/rest/v2/#tasks), you hit the `\"/tasks\"` endpoint with optional parameters `project_id`, `section_id`, `label`, etc for filtering. For example if you supply a label, it will return tasks with just that label. Whereas in the previous example the function arguments went in the `body_args` of the requestor, here these will go in the `query_args` as they are query parameters of the GET request. Here's how to set this up (I'll just implement the label filtering).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_tasks <- requestor(\n  todoist,\n  \"tasks\",\n  query_args = function_args(\n    label = NULL\n  ),\n  # simple extractor to just pick out the id and the content fields of\n  # the response, for demo purposes\n  extractor = \\(x) {\n    resp_body_json(x) |> \n      map(\\(y) y[c(\"id\", \"content\")])\n  }\n)\nget_tasks(label=\"blog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[[1]]$id\n[1] \"8604768592\"\n\n[[1]]$content\n[1] \"Write wrapify blog post\"\n```\n\n\n:::\n:::\n\n\nYou can get more details on a specific task by hitting the endpoint `tasks/{task_id}`. This kind of situation is handled by the `resource_args` argument in `requestor` as follows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_task <- requestor(\n  todoist,\n  \"tasks/{task_id}\",\n  resource_args = function_args(task_id=),\n  extractor = \\(x) {\n    resp_body_json(x)[c(\"id\", \"content\", \"description\", \"is_completed\")]\n  }\n)\nget_task(8604768592)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] \"8604768592\"\n\n$content\n[1] \"Write wrapify blog post\"\n\n$description\n[1] \"Write a blog post overview of wrapify package\"\n\n$is_completed\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n## Package tools\n\nThe intention for this package is to use it to build other packages. In general the idea would be to export all of the requestor functions, but not the `wrapper` object as the end user doesn't have much to do with that. To help with this, there's a helper function `generate_roxygen_comment` that can generate a documentation template for the requestor functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_roxygen_comment(get_task, title = \"Get a task\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#' Get a task\n#' \n#' [Add a description here]\n#' \n#' @param task_id [Description of task_id]\n#' @param .credentials Credentials to use, e.g. an API key\n#' @param .perform Perform the request? If FALSE, an httr2 request object is returned.\n#' @param .extract Extract the data? If FALSE, an httr2::response object is returned\n#' @param .extractor A function which takes an httr2::response object and returns the desired data\n#' \n#' @return [Describe the return value here]\n#' @export\n```\n\n\n:::\n:::\n\n\n\nUsing this, the full code for a `todoist` API package would look like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntodoist <- wrapper(\n  \"https://api.todoist.com/rest/v2/\",\n  auth = bearer_auth_type(),\n  env_var_name = \"TODOIST_KEY\"\n)\n\n#' Get a task\n#' \n#' Get a task by ID\n#' \n#' @param task_id the task id\n#' @param .credentials Credentials to use, e.g. an API key\n#' @param .perform Perform the request? If FALSE, an httr2 request object is returned.\n#' @param .extract Extract the data? If FALSE, an httr2::response object is returned\n#' @param .extractor A function which takes an httr2::response object and returns the desired data\n#' \n#' @return A list with the task data\n#' @export\nget_task <- requestor(\n  todoist,\n  \"tasks/{task_id}\",\n  resource_args = function_args(task_id=)\n)\n\n#' Get all tasks\n#' \n#' Get all tasks with optional filters\n#' \n#' @param label Optionally filter by label\n#' @param .credentials Credentials to use, e.g. an API key\n#' @param .perform Perform the request? If FALSE, an httr2 request object is returned.\n#' @param .extract Extract the data? If FALSE, an httr2::response object is returned\n#' @param .extractor A function which takes an httr2::response object and returns the desired data\n#' \n#' @return The data on the returned tasks\n#' @export\nget_tasks <- requestor(\n  todoist,\n  \"tasks\",\n  query_args = function_args(\n    label = NULL\n  )\n)\n```\n:::\n\n\n\nThis is all the code you would need to write to create a todoist API wrapper with those two functions. Again, I think this is pretty slick! It's a very small amount of code that produces fairly powerful output. I've found this to be extremely useful for my own purposes and would love to hear whether others find it similarly useful.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}