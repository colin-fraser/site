{
  "hash": "52e7d885aa37e4e9b070f8ba1a5d4da6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Computing big Fibonacci numbers using the Golden Ratio, abstract algebra, and S3 classes in R\"\ndate: 2024-11-20\nformat: html\ncategories:\n  - Programming\n  - R\n  - Math\n---\n\n\n\n\n\n\nThis post is a bit interdisciplinary. It stems from [a back and forth that I had on X](https://twitter.com/Almost_Sure/status/1797758878911975489) about ways of computing the Fibonacci numbers. I learned something new in that interaction, and I thought that it would be a wonderful opportunity to demonstrate some cool math and some cool R programming. If you already know the math, you might learn something about R. If you already know about R, you might learn something about math.\n\nOne of my favourite facts is that there exists [a closed form expression](https://en.wikipedia.org/wiki/Fibonacci_sequence#Closed-form_expression) for the $n$-th Fibonacci number.\n\n$$F_n = \\frac{\\varphi^n - (1-\\varphi)^n}{\\sqrt{5}}$$\n\nwhere $\\varphi = \\frac{1+\\sqrt{5}}{2}$ is the Golden Ratio. It's very surprising to me that there should be a closed-form expression for the n-th Fibonacci number, and moreover that this mess of very irrational-looking numbers can somehow sum to an integer. But if you want to use this in practice, you do have a bit of a problem: working with irrational numbers like $\\varphi$ and $\\sqrt{5}$ will inevitably lead to precision problems. But what I've recently learned, and what this post is about, is that you can use the _algebraic_ properties of $\\phi$ to avoid dealing with irrational numbers at all.\n\nOne way to see how the Fibonacci numbers connect to the Golden Ratio is by thinking about the equation that traditionally defines $\\varphi$: $\\varphi$ is the number which is one less than its square: $\\varphi^2 = \\varphi + 1$. But note that $\\varphi=\\varphi^1$, and $1 = \\varphi^0$, so we can write this same equation as $\\varphi^2 = \\varphi^1 + \\varphi^0$. This looks a bit Fibonacci-ish: the second power of $\\varphi$ is the sum of the first and zero-th powers of $\\varphi$.\n\nWhat about $\\varphi^3$? \n$$\\begin{align}\n\\varphi^3 = \\varphi \\times \\varphi^2 = \\varphi \\times (\\varphi^1 + \\varphi^0) = \\varphi^2 + \\varphi^1\n\\end{align}$$\n\nThe third power of $\\varphi$ is the sum of its first and second powers. Very Fibonacci-ish again. In fact the same reasoning will show that for any integer $n$, we will have $\\varphi^n = \\varphi^{n-1} + \\varphi^{n-2}$. So the exponents $n$ on $\\varphi$ are subject to the Fibonacci recurrence in this way.\n\nI've known all of this for a long time, but what I recently learned is that you can use all of this to compute Fibonacci numbers without ever computing the value of $\\varphi^n$ itself, or even dealing with any irrational numbers at all.\n\nThe way this is going to work is to consider numbers of the form $a + b\\varphi$, where $a$ and $b$ are integers. We're actually going to consider a whole sequence of these numbers, defined by $f_0 = 0 + \\varphi$, and $f_n=(f_0)^n = f_0 \\times f_{n-1}$.\n\nHere's where I'm going to use a little bit of R. I'm going to create an S3 class to represent this type of number. I'll call these `Z_phi` numbers. If you've never seen S3 classes before, a very good overview is given [in Hadley Wickham's Advanced R book](https://adv-r.hadley.nz/s3.html). If you know even a little bit about object oriented programming from another language, it'll look a bit weird, but you should be able to follow along. If you don't know any programming at all, just go with it; I think this should all be actually quite readable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# constructor for Z_phi numbers --- creates a \"Z_phi\" S3 object\nZ_phi <- function(a, b=0) {\n  z <- list(a = a, b = b)\n  class(z) <- \"Z_phi\"\n  z\n}\n\n# render it nicely on the screen\nformat.Z_phi <- function(x, ...) {\n  sign <- if (x$b >= 0) '+' else '-'\n  paste0(x$a, sign, abs(x$b), 'φ')\n}\nprint.Z_phi <- function(x, ...) {\n  cat(format(x), \"\\n\")\n}\n```\n:::\n\n\n\nLet's try it out.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(Z_phi(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3+4φ \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(Z_phi(1, -1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1-1φ \n```\n\n\n:::\n:::\n\n\n\nNeat. Next, we have to give them a way to add and multiply. Adding should be easy: for two of these `Z_phi` numbers $z_1 = a_1 + b_1 \\varphi$ and $z_2 = a_2 + b_2 \\varphi$, the coefficients should just sum straightforwardly: $z_1 + z_2 = (a_1 + a_2) + (b_1 + b_2)\\varphi$.\n\nMultiplication requires just a bit of simple algebra to figure out. (The third line follows from the fact that $\\varphi^2 = \\varphi + 1$).\n\n$$\\begin{align}\nz_1 \\times z_2 &= (a_1 + b_1 \\varphi) \\times (a_2 + b_2 \\varphi)\\\\\n&= a_1a_2 + a_1 b_2 \\varphi + b_1 a_2 \\varphi + b_1 b_2 \\varphi^2 \\\\\n&= a_1a_2 + (a_1 b_2 + b_1 a_2) \\varphi + b_1 b_2 (\\varphi + 1) \\\\\n&= a_1 a_2 + b_1 b_2 + (a_1 b_2 + b_1 a_2 + b_1 b_2) \\varphi\n\\end{align}\n$$\n\nNote that this is another `Z_phi` number since $a_1 a_2 + b_1 b_2$ and  $a_1 b_2 + b_1 a_2 + b_1 b_2$ are both integers. This fact is actually quite important, and nice. It means that we can add and multiply any two `Z_phi` numbers and we get another `Z_phi` number. In math, we say that this makes the set of `Z_phi` objects a *[ring](https://en.wikipedia.org/wiki/Ring_(mathematics))*, which is the name for a set of objects that you can add and multiply together. The name of this particular ring is $\\mathbb{Z}[\\varphi]$, which is why I've given these objects this name in my code.\n\nWe can implement these operations in R as follows --- if you've never seen this before, it's going to look a bit crazy because R is a bit weird, but this is really useful to know how to do.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"+.Z_phi\" <- function(e1, e2) {\n  Z_phi(e1$a + e2$a, e1$b + e2$b)\n}\n\n\"*.Z_phi\" <- function(e1, e2) {\n  a1 <- e1$a\n  b1 <- e1$b\n  a2 <- e2$a\n  b2 <- e2$b\n  Z_phi(a1 * a2 + b1 * b2, a1 * b2 + b1 * a2 + b1 * b2)\n}\n```\n:::\n\n\n\nThis lets us add and multiply `Z_phi` numbers just like any other numbers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz1 <- Z_phi(1, 2)\nz2 <- Z_phi(3, 4)\nprint(z1 + z2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4+6φ \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(z1 * z2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n11+18φ \n```\n\n\n:::\n:::\n\n\n\nWith this, we can execute the plan I laid out above. Recall, we were going to look at powers of $f_1 = \\varphi = 0 + 1\\varphi$. Let's look at the first 10.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf_0 <- f_i <- Z_phi(0, 1)\nfor (i in 1:10) {\n  print(paste0(\"φ^\", i, \" = \", format(f_i)))\n  f_i <- f_i * f_0\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"φ^1 = 0+1φ\"\n[1] \"φ^2 = 1+1φ\"\n[1] \"φ^3 = 1+2φ\"\n[1] \"φ^4 = 2+3φ\"\n[1] \"φ^5 = 3+5φ\"\n[1] \"φ^6 = 5+8φ\"\n[1] \"φ^7 = 8+13φ\"\n[1] \"φ^8 = 13+21φ\"\n[1] \"φ^9 = 21+34φ\"\n[1] \"φ^10 = 34+55φ\"\n```\n\n\n:::\n:::\n\n\n\nHopefully, something is jumping out at you. Both the sequence of $a$'s and the sequence of $b$'s form the Fibonacci sequence! In particular, noting that $\\varphi^0 = 1$, we can say that the $n$-th Fibonacci number is the $b$ coefficient of $\\varphi^n$ written as a `Z_phi` number. I won't provide a complete proof for why this is true---there should be enough here to put together the missing pieces if you want to convince yourself.\n\nTo me this feels like a cheat code. Using Binet's formula, we can compute $F_n$ in one fell swoop, but it requires doing arithmetic with the irrational number $\\varphi$, which can potentially be a bit tricky. But here, we have a way of computing $F_n$ that is somehow in terms of $\\varphi$, but does not actually involve computing or doing arithmetic using the value of $\\varphi$. The only adding and multiplying that takes place is on integers. We compute $F_n$ by taking $\\phi^n$, but we're using the algebraic properties of these `Z_phi` numbers to somehow sidestep the irrationality entirely.\n\nWhere it really starts to look like a cheat code is when you realize that now you can use the properties of exponentiation to cut down the number of steps it takes to calculate $F_n$. The classic way of calculating $F_n$ is just by recursion. Here's an example implementation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfib_classic <- function(n, zero = 0L, one = 1L) {\n  if (n == 0) {\n    return(zero)\n  } else if (n == 1) {\n    return(one)\n  }\n  v <- c(zero, one)\n  while (n > 1) {\n    v <- c(v[2], sum(v))\n    n <- n - 1\n  }\n  v[2]\n}\nfib_classic(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\nThis is pretty straightforward. The one weird thing you might notice is that I've supplied these weird `zero` and `one` arguments. Ignore that for now; I'll talk about it later.\n\nAnyway, this will take $n$ steps to calculate $F_n$. Now, you might think that this exponentiation method will take $n$ steps as well, since it involves multiplying $\\phi$ by itself $n$ times, but we can shorten this with [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring). The idea here is that $\\varphi^{10} = ((\\varphi^2)^2)^2 \\times \\varphi^2$, which can be accomplished in only around $\\log_2(n)$ steps. Here's an implementation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"^.Z_phi\" <- function(z, n) {\n  stopifnot(n >= 1)\n  if (n == 1) {\n    z\n  } else {\n    switch(n %% 2 + 1, (z * z)^(n %/% 2L), z * (z * z)^((n-1L) %/% 2L))\n  }\n}\nZ_phi(0, 1)^10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n34+55φ \n```\n\n\n:::\n:::\n\n\n\nWith all of this scaffolding in place, we can write a really concise and neat Fibonacci function. (Again, ignore the slightly unexpected `phi` argument for now; I'll come back to it).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfib_phi <- function(n, phi = Z_phi(0, 1)) {\n  z <- phi^n\n  z$b\n}\nfib_phi(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\nI just think that's so cool. We're using the algebraic properties of the Golden Ratio to compute Fibonacci numbers in an apparently closed form, but we're doing it without having to actually perform any arithmetic on the Golden Ratio itself.\n\nNow, what does this buy us? Is it faster? Based on how I've described what's going on, you'd probably expect that it is I did. Let's test it out on calculating the 50th Fibonacci number.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(classic = fib_classic(50), phi = fib_phi(50))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 classic      10.9µs   11.8µs    79084.        0B     95.0\n2 phi          28.8µs   31.3µs    30414.       9KB     73.2\n```\n\n\n:::\n:::\n\n\n\nHuh. Even though the `Z_phi` approach uses fewer steps, it still takes more than twice as long on average to find $F_{50}$. Why?\n\nI'm not an expert on this stuff, but I believe the answer is overhead. The classic method takes more steps than the $\\varphi$ method, but it's still only 50 integer additions. That's going to be fast. On the other hand, the phi method involves all kinds of extra baggage: dealing with the S3 class, putting things in lists and pulling them back out, multiplication. 50 is just too small for the extra investment to pay off. \n\nTo really see the gains, we need to look at bigger Fibonacci numbers, but there's a problem. The Fibonacci numbers grow really fast, and pretty soon we're going to get to larger numbers than R knows how to think about, no matter which method is used. The methods already disagree on the value of $F_{100}$, and in fact neither one finds the correct value of $F_{100} = 354224848179261915075$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(fib_classic(100), digits = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 354224848179261997056\n```\n\n\n:::\n\n```{.r .cell-code}\nprint((100), digits = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n\nThis is where the extra arguments that I added to the functions come in. To work with numbers this big, we'll need a package that can deal with arbitrary-precision integer arithmetic. I'll use the `{bignum}` package for this. By specifying the `zero` and `one` arguments to `fib_classic` as arbitrary-precision integers, the result will be an arbitrary-precision integer as well, and we get the right answer.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bignum)\nformat(fib_classic(100, biginteger(0), biginteger(1)), notation = \"dec\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"354224848179261915075\"\n```\n\n\n:::\n:::\n\n\n\nNow, here's something quite neat. I don't actually have to write a new `Z_phi` implementation. Everything I've done will work just fine if I supply `biginteger`s to the arguments of `Z_phi`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZ_phi(biginteger(0), biginteger(1))^100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n218922995834555169026+354224848179261915075φ \n```\n\n\n:::\n:::\n\n\n\nHere's a comparison of the speed of the two functions at computing $F_{100}$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_zero <- biginteger(0)\nbig_one <- biginteger(1)\nbench::mark(classic = fib_classic(100, big_zero, big_one), \n            phi = fib_phi(100, phi = Z_phi(big_zero, big_one)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 classic     14.45ms  14.52ms      68.9    51.3KB    999. \n2 phi          3.88ms   4.31ms     230.     16.5KB     52.3\n```\n\n\n:::\n:::\n\n\n\nNow we're talking! The `Z_phi` method takes around a third of the time to calculate $F_{100}$ compared to the classic method.\n\nIn fact, when we switch to using arbitrary precision integers, `fib_phi` catches up much faster than it did using base `numeric` variables---it overtakes somewhere around $F_{20}$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- map(\n  seq(10, 200, 10),\n  \\(x) {\n    bench::mark(classic = fib_classic(x, big_zero, big_one), \n            phi = fib_phi(x, phi = Z_phi(big_zero, big_one))) |> \n      mutate(n = x)\n  }) |> \n  list_rbind()\ndf |> \n  transmute(method = as.character(expression), n, median) |> \n  ggplot(aes(x = n, y = median, color = method)) + \n  geom_point() +\n  labs(y = expression(\"Median time to compute \" * F[n] * \"  (milliseconds)\"), x = \"n\",\n       title = expression(\"Comparison of methods up to \"*F[200])) + \n  ggthemes::theme_few()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nOnce again I have to say, this feels like a cheat code. We're somehow calculating the exact value of the _n_-th Fibonacci number by doing some Golden Ratio magic, without actually having to know the value Golden Ratio, in logarithmic time.\n\nCool stuff!",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}